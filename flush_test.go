package main

import (
	"encoding/json"
	"log"
	"os"
	"sync"
	"testing"

	proto "github.com/golang/protobuf/proto"
	"gopkg.in/go-playground/assert.v1"
)

type MemFlush struct {
	uuid    string
	records map[string][]byte
	onFetch func(string)
	last    string
}

func (m *MemFlush) LoadConfig(_ json.RawMessage) error {
	return nil
}

func (m *MemFlush) Flush(uuid, ident string, d []byte) error {
	defer m.onFetch(uuid)
	m.last = ident
	m.uuid = uuid
	m.records[ident] = d
	return nil
}

func TestBatch(t *testing.T) {
	uuid := "mock-uuid"

	t.Run("Batch", func(t *testing.T) {
		var wg sync.WaitGroup

		f := &MemFlush{
			records: map[string][]byte{},
			onFetch: func(ident string) {
				wg.Done()
			},
		}

		ch := NewBatch(uuid, 5, 2, f, nil, nil, nil)
		assert.Equal(t, 5, cap(ch))

		// Expected 3 batches.
		t.Run("Send and Receive Events", func(t *testing.T) {
			wg.Add(5)
			for i := 0; i <= 20; i++ {
				ch <- &L9Event{ID: string(i)}
			}

			wg.Wait()
			assert.Equal(t, 5, len(f.records))
			assert.Equal(t, uuid, f.uuid)

			t.Run("Protobuf unmarshal output", func(t *testing.T) {
				for ix, b := range f.records {
					ne := &L9EventBatch{}
					if err := proto.Unmarshal(b, ne); err != nil {
						t.Fatal(err)
					}

					if ix == f.last {
						assert.Equal(t, 1, len(ne.Events))
					} else {
						assert.Equal(t, 5, len(ne.Events))
					}
				}
			})

			t.Run("Flush current events on shutdown hook", func(t *testing.T) {
				exitCh := make(chan struct{})
				f := &MemFlush{
					records: map[string][]byte{},
					onFetch: func(ident string) {},
				}

				ch := NewBatch(uuid, 5, 2, f, nil, exitCh, &wg)

				// push 10 messages on channel
				for i := 0; i < 10; i++ {
					ch <- &L9Event{ID: string(i)}
				}
				// close channel to invoke shutdown scenario
				wg.Add(1)
				close(exitCh)
				wg.Wait()

				assert.Equal(t, 2, len(f.records))
				assert.Equal(t, uuid, f.uuid)
			})
		})
	})
}

func TestMain(m *testing.M) {
	log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
	os.Exit(m.Run())
}
